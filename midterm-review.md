# Midterm Exam Review: Topics and Preparation Guide

## Overview
This document serves as a comprehensive review guide for the Midterm Exam. The exam covers topics from **Week 1 to Week 7** and includes lectures and lab sessions. Use this guide to structure your revision, identify important concepts, and practice implementations.

---

## Topics by Week

### **Week 1: Course Introduction and Stable Matching**
- **Lecture 1: Course Introduction**:
  - Overview of the course structure, grading, and expectations.
  - Introduction to algorithmic problem-solving.

- **Lecture 2: Stable Matching (Gale-Shapley)**:
  - Problem definition and examples.
  - Gale-Shapley algorithm:
    - Algorithm steps.
    - Properties: Stability and Optimality.
  - Applications: Matching markets, hospital-resident allocation.

- **Lab 1: Implementing the Gale-Shapley Algorithm**:
  - Hands-on implementation of the Gale-Shapley algorithm.
  - Practice problems:
    - Matching students to universities.
    - Hospital and resident matching.

---

### **Week 2: Basics of Algorithm Analysis**
- **Lecture 3: Basics of Algorithm Analysis**:
  - Definitions of algorithms and pseudocode.
  - Time complexity and asymptotic notation:
    - Big-O, Big-Theta, and Big-Omega.
    - Examples with simple algorithms.

- **Lecture 4: Efficiency of Algorithms**:
  - Comparison of algorithms based on runtime and space usage.
  - Analyzing nested loops and recursive algorithms.

- **Lab 2: Runtime and Space Complexity Analysis**:
  - Exercises to compute runtime for given code snippets.
  - Examples of space complexity calculations for recursive functions.

---

### **Week 3: Graphs and Traversal**
- **Lecture 5: Introduction to Graphs**:
  - Definitions: Graph, nodes, edges, directed vs. undirected.
  - Representations: Adjacency matrix and adjacency list.
  - Basic graph properties: Degree, connectivity.

- **Lecture 6: Graph Traversal Methods (BFS, DFS)**:
  - Breadth-First Search (BFS):
    - Queue-based implementation.
    - Applications: Shortest path in an unweighted graph.
  - Depth-First Search (DFS):
    - Recursive and iterative implementations.
    - Applications: Detecting cycles, connected components.

- **Lab 3: BFS and DFS Implementation**:
  - Coding BFS and DFS for undirected and directed graphs.
  - Practice problems:
    - Finding the shortest path.
    - Counting connected components.

---

### **Week 4: Greedy Algorithms**
- **Lecture 7: Greedy Algorithm Overview**:
  - Characteristics of greedy algorithms.
  - Proof techniques for correctness:
    - Greedy-choice property.
    - Optimal substructure.

- **Lecture 8: Interval Scheduling and Optimal Caching**:
  - Interval scheduling problem:
    - Problem definition and solution.
  - Caching and eviction policies:
    - Optimal caching strategies.

- **Lab 4: Solving Problems Using Greedy Paradigm**:
  - Implementation of interval scheduling.
  - Practice problems:
    - Coin change problem.
    - Activity selection problem.

---

### **Week 5: Minimum Spanning Trees and Approximation**
- **Lecture 9: Minimum Spanning Trees**:
  - Concepts and definitions.
  - Algorithms:
    - Kruskal's algorithm.
    - Prim's algorithm.

- **Lecture 10: Approximation Solutions (Integer Knapsack)**:
  - Integer Knapsack problem:
    - Greedy approximation methods.
  - Analysis of approximation ratios.

- **Lab 5: Kruskal's and Prim's Algorithms**:
  - Implementation of Kruskal's and Prim's MST algorithms.
  - Practice problems:
    - Finding MST for weighted graphs.
    - Comparison of algorithm efficiencies.

---

### **Week 6: Divide and Conquer Basics**
- **Lecture 11: Divide and Conquer I**:
  - Overview of the divide and conquer paradigm.
  - Steps: Divide, Conquer, Combine.

- **Lecture 12: Sorting and Searching**:
  - Merge Sort:
    - Algorithm and time complexity.
  - Binary Search:
    - Recursive and iterative approaches.

- **Lab 6: Implementing Merge Sort and Binary Search**:
  - Implementation of merge sort.
  - Binary search applications:
    - Finding an element in a sorted array.
    - Searching for bounds (lower and upper).

---

### **Week 7: Advanced Divide and Conquer**
- **Lecture 13: Divide and Conquer II**:
  - Advanced algorithms:
    - Integer Multiplication (Karatsuba algorithm).
    - Nearest Neighbor problem in computational geometry.

- **Lecture 14: Run-time Analysis**:
  - Analyzing divide and conquer algorithms using recurrence relations.
  - Master theorem.

- **Lab 7: Advanced Divide and Conquer**:
  - Implementation of integer multiplication.
  - Practice problems:
    - Closest pair of points problem.

---

## Preparation Tips
1. **Review Lecture Notes**:
   - Focus on key definitions, algorithms, and their proofs.
   - Understand the reasoning behind algorithm design choices.

2. **Practice Lab Problems**:
   - Revisit implementation exercises from the labs.
   - Modify and extend solutions to explore edge cases.

3. **Solve Additional Problems**:
   - Use platforms like LeetCode, Codeforces, and GeeksforGeeks to practice similar problems.

4. **Create Summary Sheets**:
   - Write concise notes for each topic:
     - Key formulas.
     - Algorithm steps.
     - Time and space complexities.

5. **Discuss with Peers**:
   - Engage in study groups to clarify doubts and discuss alternative approaches.

---

## Recommended Resources
1. **Books**:
   - "Introduction to Algorithms" by Cormen, Leiserson, Rivest, and Stein.
   - "Algorithm Design" by Jon Kleinberg and Ã‰va Tardos.

2. **Online Tutorials**:
   - [GeeksforGeeks](https://www.geeksforgeeks.org/)
   - [CP-Algorithms](https://cp-algorithms.com/)

3. **Video Lectures**:
   - [MIT OpenCourseWare - Introduction to Algorithms](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/)
   - [YouTube - Abdul Bari](https://www.youtube.com/user/abdulbarikcs)